---
title: Apollo Router support for @defer
description: Incremental delivery of entity fields
---

> This feature is currently in **preview**, available in Apollo Router v1.0 and later.

Queries sent to the Apollo Router can use the `@defer` directive to enable the incremental delivery of data and improve the router's initial response time. This functionality is contained entirely within the router and does _not_ require your subgraphs to also support `@defer`!

## What is `@defer`?

The `@defer` directive ([see the RFC](https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md)) enables a client query to specify sets of fields that it doesn't need to receive data for _immediately_. This is helpful whenever some fields in a query take much longer to resolve than others.

Deferred fields are always contained within a GraphQL fragment, and the `@defer` directive is applied to that fragment (_not_ to the individual fields).

Here's an example query that uses `@defer`:

```graphql
query GetPersonAndFriends($personId: ID!) {
  person(id: $personId) {
    # Basic fields (fast)
    id
    name {
      firstName
      lastName
    }

    # highlight-start
    # Friend fields (slower)
    ... @defer {
      friends {
        id
      }
    }
    # highlight-end
  }
}
```

When resolving the above query, a GraphQL server can respond **incrementally**: it first returns data for the "basic fields", then later completes its response by returning data for the "friend fields".

To respond incrementally, the Apollo Router uses a multipart-encoded HTTP response. To use `@defer` successfully with the Apollo Router, a client's GraphQL library must _also_ support the directive by handling multipart HTTP responses correctly.


## Using `@defer` with the router

The Apollo Router can defer returning data for any of the following fields in your schema:

- Fields that are nested anywhere within an [entity type](#entity-fields-and-subfields)
- Root fields of the [`Query` type](#fields-of-query)

In most supergraphs, this represents a large percentage of all fields in the schema. [See an example of unsupported fields.](#unsupported-field-example)

### Entity fields and subfields

The Apollo Router supports using `@defer` with fields and nested subfields of [entity types](/federation/entities/) in your federated supergraph. Entities are object types with at least one `@key`, which specifies the fields that can uniquely identify any given instance of that type.

Here's an example subgraph schema that defines a `User` entity:

```graphql title="Users subgraph"
type User @key(fields: "id") {
  id: ID!
  name: Name!
  friends: [User!]!
}

type Name {
  firstName: String!
  lastName: String!
}

type Query {
  person(id: ID!): User
}
```

Because the `User` type is an entity, the router can successfully defer any query fragment that's nested somewhere within that type (at any depth).

Here are two example queries:

```graphql
query QueryA($personId: ID!) {
  person(id: $personId) {
    id
    # highlight-start
    ... @defer {
      name {
        firstName
        lastName
      }
    }
    # highlight-end
  }
}

query QueryB($personId: ID!) {
  person(id: $personId) {
    id
    name {
      firstName
      # highlight-start
      ... @defer {
        lastName
      }
      # highlight-end
    }
  }
}
```

### Fields of `Query`

The Apollo Router also supports using `@defer` with root fields of your supergraph's `Query` type:

```graphql
query PartiallyDeferredQuery {
  products {
    id
  }
  # highlight-start
  ... on Query @defer {
    users {
      id
    }
  }
  # highlight-end
}
```

It is _invalid_ to use `@defer` with root fields of the `Mutation` type.

### Non-deferred fields

A query's `@defer` fragment might include fields that the Apollo Router _can't_ defer. The router handles this case gracefully with the following logic:

- The router defers every field in the fragment that it _can_ defer.
- The router resolves the other fields in the fragment _before_ sending its initial response to the client.
- The router's response to the client still uses multipart encoding to separate `@defer` fragment fields from other fields, even if the fragment fields _couldn't actually_ be deferred.
    - This preserves the response structure that the client expects based on its uses of `@defer`.

To illustrate this behavior, let's look at some examples using this subgraph schema:

```graphql
type Book @key(fields: "id") {
  id: ID!
  title: String!
  author: Author!
}

type Author {
  name: String!
  books: [Book!]!
}

type Query {
  books: [Book!]!
  authors: [Author!]!
}
```

Note in this schema that the `Book` type is an entity and the `Author` type is _not_.


#### Example #1

Let's say a client executes the following query:

```graphql
query GetAuthors {
  authors {
    name
    # highlight-start
    ... { @defer
      books { # Can't be deferred
        title # CAN be deferred
      }
    }
    # highlight-end
  }
}
```

This query uses the root-level `Query.authors` field. It attempts to defer two fields: `Author.books` and `Book.title`.

- In this query, `Author.books` is _not_ nested anywhere within an entity type. Therefore, the router _can't_ defer it.
- `Book.title` is _always_ nested within an entity type, because `Book` is itself an entity. Therefore, the router _can_ defer it.

In this case, the router must internally resolve each author's list of associated `books` _before_ it can send its initial response to the client. Later, it can resolve each book's title and return those `Book` objects to the client in an incremental part of the response.

#### Example #2

Now, let's say a client executes the following query:

```graphql
query GetBooks {
  books {
    title
    ... @defer {
      author {
        name
      }
    }
  }
}
```

This query uses the root-level `Query.books` field. It attempts to defer two fields: `Book.author` and `Author.name`. **The router can defer both of these fields!** That's because they're both nested somewhere within an entity type (`Book`).

In this case, the router initially resolves the following query fields and returns them to the client:

```graphql
query GetBooks {
  books {
    title
  }
}
```

It later resolves both deferred fields and returns them in an incremental part of the response.
