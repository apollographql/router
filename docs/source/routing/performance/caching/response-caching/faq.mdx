---
title: Response caching FAQ for the GraphOS Router
description: Response caching FAQ for GraphOS Router with GraphOS Enterprise.
minVersion: Router v2.8.0
releaseStage: preview
---

+ What's the minimal requirement at the subgraph level to benefit from response caching ?

The Router currently cannot know which types or fields should be cached, so it requires the subgraph to set a `Cache-Control` header in its response to indicate that it should be stored.

+ Does it cache errors from response ?

To prevent transient errors from affecting the cache for a long duration, subgraph responses with errors are not cached.

+ What if one of my subgraph is unavailable ?

If some entities were obtained from the cache, but the subgraphs that provided them are unavailable, the router will return a response with the cached entities, and the other entities nullified (schema permitting), along with an error message for the nullified entities.

+ How response caching is working with authorization ?

When used alongside the router's [authorization directives](/router/configuration/authorization), cache entries are separated by authorization context. If a query contains fields that need a specific scope, the requests providing that scope have different cache entries from those not providing the scope. This means that data requiring authorization can still be safely cached and even shared across users, without needing invalidation when a user's roles change because their requests are automatically directed to a different part of the cache.

+ How does schema updates affect my cache ?

On schema updates, the router ensures that queries unaffected (it's unaffected if the subgraph schema doesn't change) by the changes keep their cache entries. Queries with affected fields need to be cached again to ensure the router doesn't serve invalid data from before the update.


+ Why use caching in the router if your customer already uses CDN, client, subgraph caching?

The router caches at the entity/query level which is GraphQL native and reusable across users and requests
Router level caching reduces traffic to subgraphs/services

+ Why was “Entity Caching” renamed to “Response Caching”?

It wasn’t always describing the outcome and could create confusions.  Response caching more accurately explains the feature and gives us room to grow and evolve it.

+ Can my customer use response caching in production with router versions < v2.8?

For TTL-based caching, yes.
For API-based invalidation, please use v2.8+

+ Router v2.8 introduces Cache Tags. Does this work with CDN caches which use surrogate cache key or cache tag?

Yes, it works in a similar and compatible way with those existing systems.

+ Why the focus on invalidation when TTL works for many customers?

Discovery shows that a majority of our customers need API-based invalidation, and customers with event-driven architectures can't achieve optimal performance with TTL-only approaches.

+ What are the issues with performance in the existing preview of caching (2024)?

In the Redis-based entity cache preview that we shipped in 2024, active invalidation fundamentally cannot scale because it uses a linear scan that consumes resources proportional to the total size of the database, not just the amount of invalidated entries. An entirely different approach is needed. This is the main reason that iteration of the feature never left preview in over a year.

+ How does the new preview released in Router v2.8 impact existing response caching users?

All changes will be backward compatible. Existing users of `preview_entity_caching` plugin will be automatically migrated over to the new plugin (`preview_response_caching`)

+ Why weren’t cache tags added to the `@cacheControl` directive?

We considered this. The `@cacheControl` directive has been around for years and is a subgraph-only directive, meaning it’s not part of the supergraph schema. We would need to manage legacy usage. Additionally, another reason to follow this approach is that it mirrors HTTP specifications. Typically, a cache-control header is used to set the TTL and specify whether data should be cached, while a surrogate-key header lists the surrogate keys.

+ What happens to root field cache entries that have no tags associated with them?

Like in today’s preview, they will eventually be removed based on TTL, you can invalidate it using either the builtin invalidation by subgraph or by entity but you won’t be able to invalidate root fields for example.

+ Does `@cacheTag` directive with any subgraph implementation ?

Yes it's not a subgraph directive, it's only interpreted at the router level unlike `@cacheControl`.

//TODO
+ Limitations on `@cacheTag` directive
+ `@cacheControl` directive
+ Limitations on queries with multiple root fields
