---
title: Writing simple logic in a scripting language
description: Using rhai script to implement simple behaviors without compiling a custom plugin
---

import { Link } from 'gatsby';

---

The router supports simple customization (via YAML configuration) and more complex customization (via a Rust Plugin Extension), but what if you want to do something slightly more complex than configuration, but don't want to write a Rust plugin. That's where our Rhai plugin steps in. Rhai is a simple scripting language, [`rhai`](http://rhai.rs), that provides basic capabilities. With Rhai it's easy to write simple scripts which manipulate strings, process headers and perform a variety of small ad-hoc programming tasks.

The rhai plugin is using the same mechanisms as native Rust plugins and has access to the same life-cycle events.

At this time our support for Rhai is deemed experimental and is rudimentary. If the experiment goes well, expect us to extend our support and make the environment more capable.

### Configuration

```yaml
rhai:
    # Currently there can only be a single rhai file.  If there are multiple
    # customizations, keep them all in a single file.
    filename: "location_of_your_rhai_script.rhai"
```

### Rhai Plugins

As with native plugins, there are 4 services, each with a request and a response, which can be used to inject extra behaviour into a router. The Rhai plugin implements eight functions (two for each service) as follows:

    - router_service_request
    - router_service_response
    - query_planning_service_request
    - query_planning_service_response
    - execution_service_request
    - execution_service_response
    - subgraph_service_request
    - subgraph_service_response

Each of these functions are optional, just implement the ones where you wish to inject behaviour. Every listed function takes a `context` as parameter with `extensions` and `headers` inside and must return a `context`.

### Examples

##### Example 1

Manipulate headers and the request context in addition to modifying the response.

```javascript
fn router_service_request(context) {
    // Verify that x-custom-header is present and has the expected value
    if context.headers["x-custom-header"] != "CUSTOM_VALUE" {
        throw "Error: you did not provide the right custom header";
    }
    context
}

fn router_service_response(context) {
    context.headers["test-header"] = "here is a test";
    if context.headers["x-custom-header"] == "CUSTOM_VALUE" {
        context.headers.greetings = "hello";
    }
    let value = context.extensions.test + 10;
    context.headers["coming_from_extensions"] = `value_${value}`;
    context.extensions.test = 42;
    context.extensions.addition = "Here is a new element in the context";

    context
}
```

#### Example 2

Convert cookies into headers for transmission to subgraphs. There is a complete working example (with tests) of this in the examples/cookies-to-headers directory.

```javascript
// This will convert all cookie pairs into headers.
// If you only wish to convert certain cookies, you
// can add logic to modify the processing.
fn subgraph_service_request(context) {
    // Find our cookies
    let cookies = context.headers["Cookie"].split(';');
    for cookie in cookies {
        // Split our cookies into name and value
        let k_v = cookie.split('=', 2);
        if k_v.len() == 2 {
            // trim off any whitespace
            k_v[0].trim();
            k_v[1].trim();
            // update our headers
            context.headers[k_v[0]] = k_v[1];
        }
    }
    // Always return the context 
    context
}
```
