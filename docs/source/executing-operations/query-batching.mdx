---
title: Query batching
description: Receive query batches with the Apollo Router
---

<ExperimentalFeature />

Learn about query batching and how to configure the Apollo Router to receive query batches.

## About query batching

Modern applications often require several requests to render a single page. This is usually the result of a component-based architecture where individual micro-frontends (MFE) make requests separately to fetch data relevant to them. Not only does this cause a performance overhead—different components may be requesting the same data—it can also cause a consistency issue. To combat this, MFE-based UIs batch multiple client operations, issued close together, into a single HTTP request. This is supported in Apollo Client and Apollo Server.

The Apollo Router supports client and subgraph query batching.

If you’re using Apollo Client, you can leverage the built-in support for batching to reduce the number of individual operations sent to the router.

Once configured, Apollo Client automatically combines multiple operations into a single HTTP request. The number of operations within a batch is client-configurable, including the maximum number in a batch and the maximum duration to wait for operations to accumulate before sending the batch.

The Apollo Router must be configured to receive query batches, otherwise it rejects them. When processing a  batch, the router deserializes and processes each operation of a batch independently, and it responds to the client only after all operations of the batch have been completed. Each operation executes concurrently with respect to other operations in the batch.

## Configure Client query batching

Both the Apollo Router and client need to be configured to support query batching.

### Configure router

#### Client Query Batching

By default, receiving client query batches is _not_ enabled in the Apollo Router.

To enable query batching, set the following fields in your `router.yaml` configuration file:

```yaml title="router.yaml"
batching:
  enabled: true
  mode: batch_http_link
```

| Attribute | Description | Valid Values | Default Value |
| :-- | :-- | :-- | :-- |
| `enabled` | Flag to enable reception of client query batches | boolean | `false` |
| `mode` | Supported client batching mode | `batch_http_link`:  the client uses Apollo Link and its [`BatchHttpLink`](/react/api/link/apollo-link-batch-http) link. | No Default |

#### Subgraph Query Batching

If Client query batching is enabled, and the router subgraphs [support query batching](https://www.apollographql.com/docs/apollo-server/api/apollo-server#allowbatchedhttprequests), then subgraph query batching may be enabled by setting the following fields in your `router.yaml` configuration file:

```yaml title="router.all_enabled.yaml"
batching:
  enabled: true
  mode: batch_http_link
  subgraph:
    # Enable batching on all subgraphs
    all:
      enabled: true
```

```yaml title="router.yaml"
batching:
  enabled: true
  mode: batch_http_link
  subgraph:
    # Configure batching support per subgraph
    subgraphs:
      subgraph_1:
        enabled: true
      subgraph_2:
        enabled: true
```

<Note>
The router can be configured to either support batching for all subgraphs or configured per each subgraph, but not both.

<Note>
There are limitations on the ability of the router to preserve batches from the client request into the subgraph requests. In particular, certain forms of queries will require data to be present before they are processed. Bearing this constraint in mind, the router will only be able to generate batches from queries which are processed which don't contain such constraints.

##### Example 1 Federated Subgraph Batching

```json title="federated-batch.json"
[
    {"query":"query MeQuery1 {\n  me {\n    id\n }\n}"},
    {"query":"query MeQuery2 {\n  me {\n    reviews {\n      body\n    }\n  }\n}"},
    {"query":"query MeQuery3 {\n  topProducts {\n    upc\n    reviews {\n      author {\n        name\n      }\n    }\n  }\n  me {\n    name\n  }\n}"},
    {"query":"query MeQuery4 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery5 {\n  me {\n    id\n }\n}"}
]
```

For that input and with the knowledge that our federated graph has 3 subgraphs, accounts, products and reviews, the router will generate a set of queries which look like this:
```
"query MeQuery1__accounts__0{me{id}}",
"query MeQuery2__accounts__0{me{__typename id}}",
"query MeQuery3__products__0{topProducts{__typename upc}}",
"query MeQuery3__accounts__3{me{name}}",
"query MeQuery4__accounts__0{me{name}}",
"query MeQuery5__accounts__0{me{id}}",
"query MeQuery2__reviews__1($representations:[_Any!]!){_entities(representations:$representations){...on User{reviews{body}}}}",
"query MeQuery3__reviews__1($representations:[_Any!]!){_entities(representations:$representations){...on Product{reviews{author{__typename id}}}}}",
"query MeQuery3__accounts__2($representations:[_Any!]!){_entities(representations:$representations){...on User{name}}}",
```
The first 6 queries may be batched and must be fetched before the final 3 queries can be executed. So, in this case, without subgraph batching you would make 9 fetches in total across the 3 subgraphs. With batching, that would reduce to 5 fetches.

| Subgraph | Fetch Count (without)| Fetch Count (with) |
|----------|----------------------|--------------------|
| accounts | 6                    | 2                  |
| products | 1                    | 1                  |
| reviews  | 2                    | 2                  |

##### Example 2 Simple Subgraph Batching

For queries which don't have required fetch constraints, subgraph batching is extremely efficient:

```json title="simple-batch.json"
[
    {"query":"query MeQuery1 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery2 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery3 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery4 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery5 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery6 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery7 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery8 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery9 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery10 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery11 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery12 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery13 {\n  me {\n    id\n }\n}"}
    {"query":"query MeQuery14 {\n  me {\n    name\n }\n}"},
    {"query":"query MeQuery15 {\n  me {\n    id\n }\n}"}
]
```

For that input and with the knowledge that our federated graph has 3 subgraphs, accounts, products and reviews, the router will generate a set of queries which look like this:
```
"query MeQuery1__accounts__0{me{id}}",
"query MeQuery2__accounts__0{me{name}}",
"query MeQuery3__accounts__0{me{id}}",
"query MeQuery4__accounts__0{me{name}}",
"query MeQuery5__accounts__0{me{id}}",
"query MeQuery6__accounts__0{me{name}}",
"query MeQuery7__accounts__0{me{id}}",
"query MeQuery8__accounts__0{me{name}}",
"query MeQuery9__accounts__0{me{id}}",
"query MeQuery10__accounts__0{me{name}}",
"query MeQuery11__accounts__0{me{id}}",
"query MeQuery12__accounts__0{me{name}}",
"query MeQuery13__accounts__0{me{id}}",
"query MeQuery14__accounts__0{me{name}}",
"query MeQuery15__accounts__0{me{id}}",
```
All of the queries may be batched. So, in this case, 15 fetches would be reduced to 1.

| Subgraph | Fetch Count (without)| Fetch Count (with) |
|----------|----------------------|--------------------|
| accounts | 15                   | 1                  |

</Note>

### Configure client

To enable batching in an Apollo client, configure `BatchHttpLink`. For details on implementing `BatchHttpLink`, see [batching operations](/react/api/link/apollo-link-batch-http/).

### Configuration compatibility

If the router receives a query batch from a client, and batching is *not* enabled, the router sends a `BATCHING_NOT_ENABLED` error to the client.

## Metrics for query batching

Metrics in the Apollo Router for query batching:

<table class="field-table metrics">
  <thead>
    <tr>
      <th>Name</th>
      <th>Attributes</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr class="required">
<td style="min-width: 150px;">

##### `apollo.router.operations.batching`

</td>
<td>

mode
[subgraph]

</td>
<td>

Counter for the number of received (from client) or dispatched (to subgraph) batches.

</td>
</tr>

<tr class="required">
<td style="min-width: 150px;">

##### `apollo.router.operations.batching.size`

</td>
<td>

mode
[subgraph]

</td>
<td>

Histogram for the size of received batches.

</td>
</tr>
</tbody>
</table>

The `subgraph` attribute is optional and if not present indicates that the metric is identifying batches received from clients. If a `subgraph` attribute is present, then the metric will be identifying batches sent to a particular subgraph.

## Query batch formats

### Request format

A query batch is an array of operations.

```graphql
[
query MyFirstQuery {
  me {
    id
  }
},
query MySecondQuery {
  me {
    name
  }
}
]
```

### Response format

Responses are provided in JSON array, with the order of responses matching the order of operations in the query batch.

```json
[
  {"data":{"me":{"id":"1"}}},
  {"data":{"me":{"name":"Ada Lovelace"}}}
]
```

## Error handling for query batching

### Batch error

If a batch of queries cannot be processed, the entire batch fails.

For example, this batch request is invalid because it has two commas to separate the constituent queries:

```graphql
[
query MyFirstQuery {
  me {
    id
  }
},,
query MySecondQuery {
  me {
    name
  }
}
]
```

As a result, the router returns an invalid batch error:

```json
{"errors":
  [
    {"message":"Invalid GraphQL request","extensions":{"details":"failed to deserialize the request body into JSON: expected value at line 1 column 54","code":"INVALID_GRAPHQL_REQUEST"}}
  ]
}
```

### Individual query error

If a single query in a batch cannot be processed, this results in an individual error.

For example, the query `MyFirstQuery` is accessing a field that doesn't exist, while the rest of the batch query is valid.

```graphql
[
query MyFirstQuery {
  me {
    thisfielddoesnotexist
  }
},
query MySecondQuery {
  me {
    name
  }
}
]
```

As a result, an error is returned for the individual invalid query and the other (valid) query returns a response.

```json
[
  {"errors":
    [
      {"message":"cannot query field 'thisfielddoesnotexist' on type 'User'",
       "extensions":{"type":"User","field":"thisfielddoesnotexist","code":"INVALID_FIELD"}
      }
    ]
  },
  {"data":{"me":{"name":"Ada Lovelace"}}}
]
```

## Known limitations

### Unsupported query modes

When batching is enabled, any batch operation that results in a stream of responses is unsupported, including:
- [`@defer`](/graphos/operations/defer/)
- [subscriptions](/graphos/operations/subscriptions/)
