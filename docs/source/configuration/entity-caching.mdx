---
title: Subgraph entity caching for the Apollo Router
subtitle: Redis-backed caching for entities
description: Subgraph entity caching for Apollo Router with GraphOS Enterprise. Cache and reuse individual entities across queries.
---

<EnterpriseFeature />

Learn how the Apollo Router can cache subgraph query responses using Redis to improve your query latency for entities in the supergraph.

## Overview

An entity gets its fields from one or more subgraphs. To respond to a client query for an entity, the Apollo Router must make multiple subgraph queries. Different clients querying the same entity can make identical, redundant subgraph queries. 

Entity caching enables the router to respond to identical subgraph queries with cached subgraph responses. The router uses Redis to cache data from subgraph query responses. Because cached data is keyed per subgraph and entity, different clients making the same client query&mdash;with the same or different query arguments&mdash;hit the same cache entries of subgraph response data.

### Benefits of entity caching

Compared to an alternative of caching entire client responses, entity caching supports finer control over both the amount of data being cached and the time to live (TTL) of cached data. If caching an entire client response, the router would have to store it with a shorter time to live, because application data can change often, with real-time data needing more frequent updates. A client-response cache might not be shareable between users, because the application data might contain personal and private information. A client-reponse cache might also duplicate a lot of data between client responses.

For example, consider the `Products` and `Inventory` subgraphs from the [Entities guide](/federation/entities):

<CodeColumns>

```graphql title="Products subgraph"
type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Int
}
```

```graphql title="Inventory subgraph"
type Product @key(fields: "id") {
  id: ID!
  inStock: Boolean!
}
```

</CodeColumns>

Assume we have a client for a shopping cart application, and it makes a query that requests the following for each product in the cart:
- The product's name and price. This data is from the `Products` subgraph.
- The product's availability in inventory. This data is from the `Inventory` subgraph.

If we were caching the entire client response, we would have to store it with a short time to live, because the cart data can change often and the real-time inventory has to be up to date. A client-response cache couldn't be shared between users, because the cart is personal. We might also duplicate a lot of data between client responses, because a lot of the products might appear in multiple carts.

With entity caching enabled for this example, the router is able to:
- Store each product's description and price separately with large TTL.
- Minimize the number of subgraph queries made by each client query, with potentially some client queries making zero subgraph queries and instead fetching all product data from cache.
- Share the product cache between all users.
- Cache the cart per user, with a small amount of data.
- Cache inventory data with a low TTL or not cache it at all.

## Use entity caching

Follow this guide to enable and configure entity caching in the Apollo Router.

### Prerequisites

To use entity caching in the Apollo Router, you must set up:

- A Redis instance or cluster that your router instances can communicate with.
- A [GraphOS Enterprise plan](https://www.apollographql.com/pricing/) that [connects your router to GraphOS](./overview/#environment-variables).

### Configure router for entity caching

In `router.yaml`, configure `experimental_entity_cache`:
- Enable entity caching globally.
- Configure Redis, using the same conventions described in [distributed caching](./distributed-caching).
- Configure entity caching per subgraph, with overrides per subgraph for disabling entity caching and TTL.

For example:

```yaml title="router.yaml"
experimental_entity_cache:
  enabled: true

  redis:
    urls: ["redis://..."]
    timeout: 5ms # Optional, by default: 2ms
    ttl: 24h # Optional, by default no expiration

  subgraphs:
    accounts:
      enabled: false # disable for a specific subgraph
    reviews:
      ttl: 120s # overrides the global TTL
```

### Configure time to live (TTL)

Besides configuring a global TTL for all the entries in Redis, the Apollo Router also honors the `Cache-Control` header returned with the subgraph response. It generates a `Cache-Control` header for the client response by aggregating the TTL information from all response parts.

### Customize Redis cache key

If you need to store data for a particular query in different cache entries, the cache key can be configured through the `apollo_entity_cache::key` context entry. This entry contains an object with the `all` field to affect all subgraph queries under one client query, and fields named after subgraph operation names to affect individual subgraph queries. The value of the field can be any valid JSON value (object, string, etc).

```json
{
    "all": 1,
    "subgraph_operation1": "key1",
    "subgraph_operation2": {
      "data": "key2"
    }
}

```

## Implementation notes

### Responses with errors not cached

To prevent transient errors from affecting the cache for a long duration, subgraph responses with errors are not cached.

### Authorization and entity caching

When used alongside the router's [authorization directives](./authorization), cache entries are separated by authorization context. If a query contains fields that need a specific scope, the requests providing and not providing that scope have different cache entries. This means that data requiring authorization can still be safely cached and even shared across users, without needing invalidation when a user's roles change because their queries are automatically directed to a different part of the cache.

### Schema updates and entity caching

On schema updates, the router makes sure that queries unaffected by the changes will keep their cache entries. Queries with affected fields will need to be cached again, making sure that we don't serve invalid data from the cache after the update.

### Entity cache invalidation not supported

Cache invalidation is not yet supported and is planned for a future release.
