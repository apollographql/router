---
title: Apollo Router usage and config
sidebar_title: ⚙️ Usage and config
---

> For installation instructions, see the [quickstart](../quickstart/).

You run Apollo Router with the following command (assuming you're in the same directory as the `router` executable):

```bash
./router --config configuration.yaml --supergraph supergraph-schema.graphql
```

Options are described below.

## Options

<table class="field-table api-ref">
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>

<tr class="required">
<td>

##### `-s` / `--supergraph`

</td>
<td>

The absolute or relative path to the router's [supergraph schema](https://www.apollographql.com/docs/federation/#federated-schemas).

To learn how to compose your supergraph schema with the Rover CLI, see the [Federation quickstart](https://www.apollographql.com/docs/federation/quickstart/#3-compose-the-supergraph-schema).

**Required** unless you provide this value via the `SCHEMA_PATH` environment variable.

</td>
</tr>

<tr>
<td style="min-width: 150px;">

##### `-c` / `--config`

</td>
<td>

The absolute or relative path to the router's optional [YAML configuration file](#configuration-file).

You can also provide this value via the `CONFIGURATION_PATH` environment variable.

</td>
</tr>

<tr>
<td style="min-width: 150px;">

##### `--log`

</td>
<td>

Log level which may be one of: `off`, `error`, `warn`, `info`, `debug`, or `trace`.

Default: `info`

</td>
</tr>

</tbody>
</table>

## Handling CORS

If you attempt to query Apollo Router from a browser-based client, your request might be rejected due to CORS policies.

You can configure CORS in the [YAML configuration file](#configuration-file) you can provide to Apollo Router.

Here's an example configuration for adding `localhost` to the list of approved origins:

```yaml
# examples/nodejs/configuration.yaml
server:
  listen: 127.0.0.1:4000
  cors:
    origins:
      - https://studio.apollographql.com
      - http://localhost
```

## Logging

Apollo Router detects if the stdout is a TTY and enables JSON logging only if it is not.

## Configuration file

Apollo Router takes an **optional** YAML configuration file as input via the `--config` option. To show the full possibility of options, all supported configuration options are illustrated below:

```yaml:title=configuration.yaml
#
# The Apollo Router doesn't require a configuration file to run.  This
# example is a verbose representation of possible configuration.  It's
# more of an "everything and the kitchen sink" of potential configuration
# rather than any recommendation.
#

#
# server: Configuration of the HTTP server
#
server:
  # The socket address and port to listen on
  # Defaults to 127.0.0.1:4000
  listen: 127.0.0.1:4000

  #
  # CORS (Cross Origin Resource Sharing)
  #
  cors:
    # Set to false to disallow any origin and rely exclusively on `origins`
    # Defaults to true
    allow_any_origin: true
    # List of accepted origins
    origins:
      - https://studio.apollographql.com
    # Set to true to add the `Access-Control-Allow-Credentials` header
    allow_credentials: false
    # The headers to allow.
    # Defaults to the required request header for Apollo Studio: Content-Type
    allow_headers: [ Content-Type ]
    # Allowed request methods
    # Defaults to GET, POST, OPTIONS.
    methods: [ GET, POST, OPTIONS ]
    # Which response headers should be made available to scripts running in the
    # browser in response to a cross-origin request.
    expose_headers:

#
# Subgraphs
#
# This configuration affects the communication with underlying subgraphs.
# The `subgraphs` property is a map to individual named subgraphs and should
# map to the subgraph name that is defined in the Supergraph.
#
# On each named subgraph of the subgraphs map, these properties can be set:
#
#  - routing_url
#  - layers
#
# These are explained further below.
#
# * routing_url *
#
# The URL the Router should connect to for this subgraph.
#
# By default, routing information is parsed from the supergraph which is
# typically sufficient for most environments and respects the settings which
# you've set during composition in Apollo Studio or via Rover.  Provide it here
# only to *override* the supergraph's subgraph routing URLs.
#
#
# * layers *
#
# This is a map of configurable layers which will be invoked.
#
# Layers are features (either native or extensions) which can be enabled for
# each subgraph.  Common layers are the "headers*" layers, and an example can be
# found for below.  For more information, see later in the documentation.
#

subgraphs:
  # Specifies the runtime configuration for talking to the "accounts" subgraph.
  accounts:
    # The URL of the "accounts" subgraph's GraphQL endpoint
    routing_url: http://localhost:4001/graphql

    # Layers to be applied to the "accounts" subgraph.
    layers:
      - headers_propagate:
          matching:
            regex: ^upstream-header-.*
      - headers_propagate:
          named:
            name: "old-name"
            rename: "new-name"
            default_value: "0"
      - headers_propagate:
          named:
            name: "old-name"
            rename: "new-name"
            default_value: "0"
      - headers_remove:
          name: "x-legacy-account-id"
      - headers_remove:
          matching:
            regex: ^x-deprecated.*
      - headers_insert:
          name: "router-subgraph-name"
          value: "accounts"

  # Specifies the runtime configuration for talking to the "products" subgraph.
  products:
    # The URL of the "products" subgraph's GraphQL endpoint
    routing_url: http://localhost:4003/graphql

    # Layers to be applied to the "products" subgraph.
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "products"
      - headers_remove:
          name: "x-legacy-tracking-id"


# graph configuration, see documentation below
# graph:

# spaceport configuration, see documentation below
# spaceport:

# OpenTelemetry configuration, see documentation below
# opentelemetry:
```

## Configuring headers received by subgraphs

Passing headers is supported by leveraging pre-built functionality in the Router known as "layers".  They are therefore defined in the pipeline as members of the named `subgraphs` member (e.g., `reviews`, `products`; often, certain headers only go to certain services) and further defined within the `layers` array.  The `layers` are an array since they're applied in an ordered fashion and later layers may override a previous layer's actions.

There are a few specific layers which offer different header functionality:

- **`headers_propagate`**

  This allows _selectively_ adding headers which were client-originated to the requests made to _specific_ subgraphs.

  They can be configured based on a `matching` pattern using [`regex`]:

  ```yaml
      - headers_propagate:
          matching:
            regex: .*
  ```

  [`regex`]: https://docs.rs/regex/latest/regex/

  Or by a static string using the `named` option.  These `named` configurations have additional flexibility since they can have either:

  * `default_value`: A value to set in the event that one was not sent by the client.
  * `rename`: Allow the header's key to be renamed to a new name.

  Additionally, both `default_value` and `rename` can be paired together:

  ```yaml
      - headers_propagate:
          named:
            name: "foo"
            default_value: "bar"
            rename: "fii"
          named:
            name: "Authorization"

- **`headers_remove`**

  The `headers_remove` layer allows removing a header that was client-originated and not sending it to a specific subgraph.  In the same way as `headers_propagate` can match either exactly or based on a regular expression using [`regex`].

  ```yaml
      # Do not send this service the "Cookie" header.
      - headers_remove:
          name: "Cookie"
      - headers_remove:
          matching:
            # Remove headers using the legacy 'x-' prefix.
            regex: ^x-.*$
  ```

- **`headers_insert`**

  The `headers_insert` layer allows adding a header to requests going to a specific subgraph.  In this case, this header is a static string that is originated in the router, rather than a header being sent from the client.

  ```yaml
      - headers_insert:
          name: "sent-from-our-apollo-router"
          value: "indeed"
  ```

In order to clearly see the hierarchy, here is an example of how two headers are configured for an `accounts` and a `products` subgraph.  These two subgraphs will both be sent `router-subgraph-name` headers with either the `accounts` or `products` value, respectively.  Any other subgraph will not receive any headers at all.

```yaml
subgraphs:
  # These headers apply to the "accounts" subgraph only.
  # They will not be passed to the "products" subgraph (below).
  accounts:
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "accounts"
  products:
    # Layers to be applied to the "products" subgraph only.
  # They will not be passed to the "accounts" subgraph (above).
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "products"
```

## Tracing

The Apollo Router supports [OpenTelemetry](https://opentelemetry.io/), it has exporters for [Jaeger](https://www.jaegertracing.io/) and for the [OpenTelemetry Protocol (OTLP)](https://aws-otel.github.io/docs/components/otlp-exporter) over HTTP or gRPC.
It will generate a trace of the various phases of the GraphQL query and their dependencies.

It will send a `TraceParent` header to subgraphs so they can create and send their own spans under the same trace.
If the request to the Router already contains a `TraceParent` header, it will use its value as trace id instead of generating a random one.

### Using Jaeger

```yaml:title=configuration.yaml
server:
  listen: 127.0.0.1:4000
opentelemetry:
  jaeger:
    # optional: if not present, jaeger will use the default UDP agent address
    #endpoint:
      # address for the UDP agent mode
      # incomptable with collector
      # agent: "127.0.0.1:1234"

      # URL of the HTTP collector
      # collector:" http://example.org"
      # the username and password are obtained from the environment variables
      # JAEGER_USERNAME and JAEGER_PASSWORD

    # name of the service used in traces
    # defaults to router
    service_name: "router"
    
    trace_config:
      # trace sampling, possible values are `AlwaysOn`, `AlwaysOff` or `TraceIdRatioBased: number`
      # the ratio sampler takes a value between 0 and 1 and decides at the trace creation if it will
      # be recorded or not
      sampler:
        TraceIdRatioBased: 0.42
      max_events_per_span: 1
      max_attributes_per_span: 2
      max_links_per_span: 3
      max_attributes_per_event: 4
      max_attributes_per_link: 5
      resource:
        attrs:
          key1:
            String: value
          key2:
            Bool: true
          key3:
            I64: 42
          key4:
            F64: 42.0
          key5:
            Array:
              String:
                - value1
                - value2
```

### Using OTLP


```yaml:title=configuration.yaml
server:
  listen: 127.0.0.1:4000
opentelemetry:
  # Configuration to send traces and metrics to an OpenTelemetry Protocol compatible service
  otlp:
    tracing:
      exporter:
        # 'http' for OTLP/HTTP, 'grpc' for OTLP/gRPC
        http:
          # URL of the exporter
          endpoint:
          # Possible options: 'Grpc' for GRPC protocol and 'HttpBinary' for HTTP protocol with binary protobuf
          protocol: Grpc
          # timmeout in seconds
          timeout: 60
          metadata:
            - foo: bar
      trace_config:
        # trace sampling, possible values are `AlwaysOn`, `AlwaysOff` or `TraceIdRatioBased: number`
        # the ratio sampler takes a value between 0 and 1 and decides at the trace creation if it will
        # be recorded or not
        sampler:
          TraceIdRatioBased: 0.42
        max_events_per_span: 1
        max_attributes_per_span: 2
        max_links_per_span: 3
        max_attributes_per_event: 4
        max_attributes_per_link: 5
        resource:
          attrs:
            key1:
              String: value
            key2:
              Bool: true
            key3:
              I64: 42
            key4:
              F64: 42.0
            key5:
              Array:
                String:
                  - value1
                  - value2
```

## Spaceport

Spaceport reports usage data to the Apollo ingress. You can see how it is configured in the examples above.

NB: This component is still evolving and you should expect functionality to change and evolve here. We are actively seeking user feedback as we work to shape this component.

### No usage reporting

If you don't wish to take advantage of usage reporting, then no configuration is required. This is the default.

### Usage reporting

```yaml:title=configuration.yaml
# Apollo Studio Graph configuration details
# If we don't specify a graph section, then no statistics are collected for
# processing, since there is no point collecting statistics unless we have
# somewhere to send them.
graph:
  # Which graph should our Spaceport be sending data about?
  reference: Benchmarking@current
  # Key used to send data
  key: service:<redacted>
```

To enable usage reporting, configure the `graph` section.  Within the `graph` section, both the `reference` and the `key` must be specified. The `reference` must refer to a valid graph/variant combination against which statistics are reported. The `key` must be a valid, [Contributor API key](https://www.apollographql.com/docs/studio/org/members/#organization-wide-member-roles) which can be used for reporting statistics.
For more details on this process, refer to the [usage reporting documentation](https://www.apollographql.com/docs/studio/metrics/usage-reporting/)
The `key` value fulfills the same function as the `APOLLO_KEY` environment variable in Apollo Server, Apollo Gateway and the Rover CLI.
Similarly, the `reference` fulfills the same function as the `APOLLO_GRAPH_REF` environment variable.

> **Note:** These environment variables are *not* currently recognised by the router. This is being tracked by [issue #425](https://github.com/apollographql/router/issues/425).  Please follow and enage on that issue if you're interested in this functionality!

### Spaceport configuration

Spaceport can either be run as an internal, router-specific component or as an external resource shared by multiple routers.

```yaml:title=configuration.yaml
# Spaceport configuration. These values are the default values if not specified
spaceport:
  # By default, Apollo Router will run an internal collector.  It can be
  # configured to not do this by setting this to `true`.  When `true`, no
  # agent will spawn and we will attempt to communicate to `collector` below.
  external: false
  
  # This can be left unconfigured when `external` is `false`.  When `true`,
  # this should be the location of a spaceport that is running external from
  # the Router.
  collector: https://127.0.0.1:50051

  # For an internal spaceport instance (when `external` is `false`), what
  # interface and port should we listen on.
  listener: 0.0.0.0:50051
```

#### Internal spaceport

This is the default appropriate for most cirumstances, including many production deployments.  This is the default collector mode and requires no additional configuration, so long as the `graph` configuration is set with a `reference` and `key`.

In this mode it is possible to further configure the address at which the internal spaceport is listening via the `listener` property.  Configuring a `listener` should only be necessary if there is a clash on the default port that Router chooses (e.g., if running multiple routers or other applications using the same port on the same host), of if it's desirable to change the bind address.

#### External spaceport

Running an external spaceport _is not necessary in most circumstances_.  It may be desireable in certain production environments where configuration of sensitive key data or allocation of reporting resources needs to be operated centrally.  Under heavier workloads, it can also be beneficial to externalize the trace processing to reduce the amount of work that individiual Router instances take on.  The `listener` parameter is ignored for an external spaceport.

To enable the external spaceport, another Router can be run to act as the collector with the exclusive role of processing Studio data.  To configure this, the "collector" should have `external` set to `false` and an appropriate `listener` address and port combination.  Routers exporting Studio data should have `external` set to `true`, `listener` unspecified, and their `collector` property configured to point to the collector Router.

If you're looking for help with this feature, please [open a Discussion](https://github.com/apollographql/router/discussions). 
