---
title: Apollo Router customizations
description: Extend your router with custom functionality
---

You can create **customizations** for the Apollo Router to add functionality that isn't available via built-in [configuration options](../configuration/overview/). For example, you can make an external call to fetch authentication data for each incoming request.

## Customization types

The Apollo Router supports the following customization types:

- [**Rhai scripts**](./rhai/)
    - The [Rhai scripting language](https://rhai.rs/book/) lets you add functionality directly to your stock router binary by hooking into different phases of the router's request lifecycle.
- [**External co-processing**](./coprocessor/) ([Enterprise feature](../enterprise-features/))
    - If your organization has a [GraphOS Enterprise plan](https://www.apollographql.com/pricing/), you can write custom request-handling code in any language. This code can run in the same container as your router or separately.
    - The router calls your custom code via HTTP, passing it the details of each incoming client request.

**Use [Rhai scripts](./rhai/) if they support your use case.** External co-processing is most helpful if your customization needs to do any of the following (which Rhai scripts _don't_ support):

- Read or write to disk
- Make network requests
- Use libraries from a particular language or framework

## The request lifecycle

Customizations intervene at specific points of the request lifecycle, depending on the task you want to perform. Each point is represented by a specific service with specific request and response objects.

```mermaid
flowchart RL
    subgraph client["Client"]
    end

    subgraph router["Apollo Router"]
        direction LR
        routerService("Router <br/> Service")
        supergraphService("Supergraph <br/> Service")
        executionService("Execution <br/> Service")
        subgraphService("Subgraph <br/> Service")
        routerService -->|request| supergraphService -->|request| executionService -->|request| subgraphService
        subgraphService -->|response| executionService -->|response| supergraphService -->|response| routerService

    end

    subgraph infra["Your infrastructure"]
      direction TB
      api1("subgraph A");
      api2("subgraph B");
      api3("subgraph C");
      api1 --- api2 --- api3 

    end

client -->|request| router -->|request| infra

infra -->|response| router -->|response| client
```

Each service can have a set of plugins. For requests, the plugins are executed before the service.

```mermaid
flowchart LR
  subgraph Service
    Plugin1["Plugin 1"] -->|request| Plugin2["Plugin 2"] -->|request| coreService["Core <br/>service"]
    coreService
  end

Client -->|request| Plugin1
coreService -->|request| NextService["Next service"]
```

For responses, the plugins are executed after the service.

```mermaid
flowchart RL
  subgraph Service
    coreService["Core <br/>service"] -->|response| Plugin2["Plugin 2"]  -->|response| Plugin1["Plugin 1"]   
  end

Plugin1["Plugin 1"] -->|response| Client
NextService["Next service"] -->|response| coreService
```

Each request and response object contains a `Context` object, which is carried throughout the entire process. Each request's `Context` object is unique. You can use it to store plugin-specific information between the request and response or to communicate between different hook points. (A plugin can be called at multiple steps of the request lifecycle.)

### Lifecycle flowchart

The following flowcharts diagram the entire request lifecycle.
The first details the path of a request from a client, through the parts of the Apollo Router, all the way to your subgraphs.
The second details the path of a response from your subgraphs back to the client.
Continue reading for details on what occurs in each service.

#### Request path

```mermaid
flowchart TB;
    client(Client);
    subgraph router["Apollo Router"]
        direction LR
        httpServer("<code>HTTP server</code>")
        subgraph routerService["<code>RouterService</code><br/>"]
            routerPlugins[[Router plugins]];
        end
        subgraph " "
            subgraph supergraphService["<code>SupergraphService</code>"]
                supergraphPlugins[[Supergraph plugins]];
            end
            queryPlanner("<code>QueryPlanner</code>");
        end
        
        
        subgraph executionService["<code>ExecutionService</code>"]
            executionPlugins[[Execution plugins]];
        end

        subgraph subgraphService["<code>SubgraphServices</code>"]
            subgraph service1["<code>SubgraphServiceA</code>"]
            subgraphPlugins1[[Subgraph plugins]];
            end
            subgraph service2["<code>SubgraphServiceB</code>"]
            subgraphPlugins2[[Subgraph plugins]];
            end            
        end
    end;
subgraphA[Subgraph A];
subgraphB[Subgraph B];

client --"1. HTTP request"--> httpServer;
httpServer --"2. Router request"--> routerService;
routerService --"3. Supergraph request"--> supergraphService
supergraphService --"4. Query"--> queryPlanner;
queryPlanner --"5. Query plan"--> supergraphService;
supergraphService --"6. Execution request"--> executionService;

executionService --"7a. Subgraph request"--> service1;
executionService --"7b. Subgraph request"--> service2;

service1 --"8a. HTTP Request"--> subgraphA;
service2 --"8b. HTTP Request"--> subgraphB;
```

---

#### Request path

```mermaid
flowchart TB;
    client(Client);
    subgraph router["Apollo Router"]
        direction LR
        httpServer("<code>HTTP server</code>")
        subgraph routerService["<code>RouterService</code><br/>"]
            routerPlugins[[Router plugins]];
        end
        subgraph " "
            subgraph supergraphService["<code>SupergraphService</code>"]
                supergraphPlugins[[Supergraph plugins]];
            end
            queryPlanner("<code>QueryPlanner</code>");
        end
        
        
        subgraph executionService["<code>ExecutionService</code>"]
            executionPlugins[[Execution plugins]];
        end

        subgraph subgraphService["<code>SubgraphServices</code>"]
            subgraph service1["<code>SubgraphServiceA</code>"]
            subgraphPlugins1[[Subgraph plugins]];
            end
            subgraph service2["<code>SubgraphServiceB</code>"]
            subgraphPlugins2[[Subgraph plugins]];
            end            
        end
    end;
subgraphA[Subgraph A];
subgraphB[Subgraph B];

client --"1. HTTP request"--> httpServer;
httpServer --"2. Router request"--> routerService;
routerService --"3. Supergraph request"--> supergraphService
supergraphService --"4. Query"--> queryPlanner;
queryPlanner --"5. Query plan"--> supergraphService;
supergraphService --"6. Execution request"--> executionService;

executionService --"7a. Subgraph request"--> service1;
executionService --"7b. Subgraph request"--> service2;

service1 --"8a. HTTP Request"--> subgraphA;
service2 --"8b. HTTP Request"--> subgraphB;
```

---


### Router service

The router service is called right after the HTTP server. The `RouterRequest` contains HTTP headers and the body as a stream of byte arrays. The `RouterResponse` contains HTTP headers and the body as a stream of byte arrays. The router service handles Automatic Persisted Queries, parses the GraphQL request from JSON, calls the supergraph service, and serializes the GraphQL responses to JSON.

### Supergraph service

The supergraph service works on a `SupergraphRequest` containing HTTP headers and a GraphQL request object. The `SupergraphResponse` contains headers and a stream of GraphQL responses. That stream only contains one element for most queries—it can contain more if the query uses the `@defer` directive or subscriptions.

The supergraph service calls into the query planner, which returns a query plan. The supergraph service then calls the execution service.

### Execution service

The execution service is tasked with executing the query plan. The `ExecutionRequest` contains the `SupergraphRequest` and the query plan. The `ExecutionResponse` has the same content as the `SupergraphResponse`.

For each fetch node of the query plan, the execution service creates a subgraph request and then calls the subgraph plugins and service. Once the execution service has received all subgraph responses, it formats the GraphQL responses—removing unneeded data and propagating nulls—before sending it back to the supergraph plugin.

### Subgraph service

The subgraph service wraps a subgraph: it transforms the subgraph request in an HTTP request to that subgraph. The `SubgraphRequest` contains:
- the (read-only) `SupergraphRequest`
- HTTP headers
- a GraphQL request object as the request body
- and the subgraph request's operation type (query, mutation, or subscription)

The `SubgraphResponse` contains HTTP headers and a GraphQL response.

Each subgraph has its own subgraph service, and each service can have its own subgraph plugin configuration.

