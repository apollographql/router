mod conditions_validation;
mod satisfiability_error;
mod validation_context;
mod validation_state;
mod validation_traversal;

use std::sync::Arc;

use crate::api_schema;
use crate::composition::satisfiability::validation_traversal::ValidationTraversal;
use crate::error::CompositionError;
use crate::error::FederationError;
use crate::merger::merge::CompositionOptions;
use crate::query_graph::QueryGraph;
use crate::query_graph::build_federated_query_graph;
use crate::query_graph::build_query_graph::build_query_graph;
use crate::schema::ValidFederationSchema;
use crate::supergraph::CompositionHint;
use crate::supergraph::Merged;
use crate::supergraph::Satisfiable;
use crate::supergraph::Supergraph;

pub fn validate_satisfiability(
    supergraph: Supergraph<Merged>,
) -> Result<Supergraph<Satisfiable>, Vec<CompositionError>> {
    let mut errors = vec![];
    let mut hints = vec![];
    let supergraph_schema = match validate_satisfiability_inner(supergraph, &mut errors, &mut hints)
    {
        Ok(supergraph_schema) => supergraph_schema,
        Err(error) => {
            return Err(vec![CompositionError::InternalError {
                message: error.to_string(),
            }]);
        }
    };
    if !errors.is_empty() {
        return Err(errors);
    }
    Ok(Supergraph::<Satisfiable>::new(supergraph_schema, hints))
}

fn validate_satisfiability_inner(
    supergraph: Supergraph<Merged>,
    errors: &mut Vec<CompositionError>,
    hints: &mut Vec<CompositionHint>,
) -> Result<ValidFederationSchema, FederationError> {
    // TODO: Avoid this clone by holding `FederationSchema` directly in `Merged` struct.
    let supergraph_schema = ValidFederationSchema::new(supergraph.state.schema().clone())?;
    let api_schema = api_schema::to_api_schema(supergraph_schema.clone(), Default::default())?;

    // TODO: FED-570
    let api_schema_query_graph = build_query_graph("supergraph".into(), api_schema.clone())?;
    let federated_query_graph = build_federated_query_graph(
        supergraph_schema.clone(),
        api_schema.clone(),
        Some(true),
        Some(false),
    )?;
    validate_graph_composition(
        supergraph_schema.clone(),
        Arc::new(api_schema_query_graph),
        Arc::new(federated_query_graph),
        // TODO: Pass composition options through once upstream function APIs have been updated.
        &Default::default(),
        errors,
        hints,
    )?;
    Ok(supergraph_schema)
}

/// Validates that all the queries expressible on the API schema resulting from the composition of
/// a set of subgraphs can be executed on those subgraphs.
#[allow(dead_code)]
fn validate_graph_composition(
    // The supergraph schema generated by composition of the subgraph schemas.
    supergraph_schema: ValidFederationSchema,
    // The query graph of the API schema generated by the supergraph schema.
    api_schema_query_graph: Arc<QueryGraph>,
    // The federated query graph corresponding to the composed subgraphs.
    federated_query_graph: Arc<QueryGraph>,
    composition_options: &CompositionOptions,
    errors: &mut Vec<CompositionError>,
    hints: &mut Vec<CompositionHint>,
) -> Result<(), FederationError> {
    ValidationTraversal::new(
        supergraph_schema,
        api_schema_query_graph,
        federated_query_graph,
        composition_options,
    )?
    .validate(errors, hints)
}
