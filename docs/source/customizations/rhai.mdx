---
title: Rhai scripts for the Apollo Router
description: Extend router functionality without compiling a custom plugin
---

> ⚠️ Apollo Router support for Rhai scripting is currently experimental. For details, see [experimental limitations](#experimental-limitations).

The Apollo Router provides experimental support for scripts that use the [Rhai](http://rhai.rs) scripting language. Rhai is useful for performing common script-based tasks (manipulating strings, processing headers, etc.) in a Rust-based project. If you want to learn more about simple programming with Rhai, the [book](https://rhai.rs/book/) has a [language reference](https://rhai.rs/book/language/) which is very helpful.

Rhai scripts hook into the same [Apollo Router lifecycle events](./overview/#how-customizations-work) as native Rust plugins.

## Experimental limitations

Like the rest of the Apollo Router, Rhai support is in active development. At this time, functionality is limited.

**What you can do:**
* Manipulate request/response HTTP headers
* Manipulate request/response context
* Perform `checkpoint`-style short circuiting of requests
* Modify the status codes of requests/responses
* Modify the body of requests (excluding variables)
* Modify the body of responses

**What you can't do (yet):**
* Execute calls to external services

> ⚠️ As Rhai script is experimental, we may introduce breaking changes to Rhai script functionality after the general availability (GA) release of the Apollo Router. However, any required updates to your existing scripts will probably be minor.

## Configuration

```yaml
plugins:
  experimental.rhai:
    # Currently there can only be a single rhai file.  If there are multiple
    # customizations, keep them all in a single file.
    filename: "location_of_your_rhai_script.rhai"
```

## Rhai Router Execution Environment
The main source of information about Rhai is the book (see above). That's where to look for general rhai programming questions or advice on how to interact with arrays or manipulate strings or program control flow or (...).

This section covers functionality specific to how router functionality is exposed to Rhai.

### Global State

The execution state of all router rhai scripts contains a constant, `apollo_start`, which may be used for relative timing operations. (Consider it similar to the EPOCH in unix environments.)

```javascript
fn router_service(service) {
    // Define a closure to process our response
    let f = |response| {
        let start = apollo_start.elapsed;
        // ... Do some processing
        let duration = apollo_start.elapsed - start;
        print(`response processing took: ${duration}`);

        // Log out any errors we may have
        print(response.body.errors);
    };
    // Map our response using our closure
    service.map_response(f);
}
```
### Logging

If you print() a message then it will be logged to the router logs at info level. If you want more control over the log level, then there are a series of logging functions:

```javascript
print("this is a sample message");
log_error("this is error level log message");
log_warn("this is warn level log message");
log_info("this is info level log message");
log_debug("this is debug level log message");
log_trace("this is trace level log message");
```

### Exceptions

If you wish to indicate to the client that an error has occurred, Rhai supports exceptions. Throwing an exception will terminate processing and return an INTERNAL_SERVER_ERROR to the client.

For example:
```javascript
fn router_service(service) {
    // Define a closure to process our response
    let f = |response| {
        // Something goes wrong during response processing...
        throw "an error occurred setting up the router_service...");
    };
    // Map our response using our closure
    service.map_response(f);
}
```

### Service hooks

Similar to native Rust plugins, Rhai scripts can hook into the Apollo Router's [four services](./overview/#how-customizations-work) that handle requests. Just like native Rust plugins, Rhai scripts use a single hook for each service. Like native Rust plugins, the script author can then choose to map requests/response and generally configure the service for different behaviour.

  - `router_service`
  - `query_planner_service`
  - `execution_service`
  - `subgraph_service`

Each of these hooks is optional. Define only the functions you want to use custom logic for.

Each function takes a single parameter: `service`, this is typed for each of the different services. The various service functions are not required to return anything. If they do, the return is ignored.

```javascript
fn router_service(service) {}
fn query_planner_service(service) {}
fn execution_service(service) {}
fn subgraph_service(service) {}
```

### Service Interface

The full functionality of a Rust plugin is not available, but the following methods are available for service interactions.

  - `map_request`
  - `map_response`

These can be invoked as methods on the supplied service object and are expected to provide a callback function (or closure) which is invoked for actual request or response processing.

For example:
```javascript
fn router_service(service) {
    // Define a closure to process our response
    let f = |response| {
        // Log out any errors we may have
        print(response.body.errors);
    };
    // Map our response using our closure
    service.map_response(f);
}
```

### Request Interface

All requests expose a mechanism for interacting with request Body, Headers and Context.

```
request.context
request.headers
request.body.query
request.body.operation_name
request.body.variables
request.body.extensions
```

In addition, SubgraphRequest, exposes the additional ability to interact with headers sent to subgraphs:

```
request.sub_headers
```

All of the above are read/write *apart* from `request.body.variables` which is read-only.

### Response Interface

Most responses expose a mechanism for interacting with response Body, Headers and Context. QueryPlannerResponse only exposes a Context, since there are no Body or Headers accessible at that stage.

```
response.context
response.headers
response.body.label
response.body.data
response.body.errors
response.body.extensions
```

All of the above are read/write.

## Full Examples

### Example 1

This example illustrates how to register router request handling.

```javascript

// At the router_service stage, register callbacks for processing requests
fn router_service(service) {
    let request_callback = Fn("process_request"); // This is standard Rhai functionality for creating a function pointer
    service.map_request(request_callback); // Register the callback
}

// Generate a log for each request
fn process_request(request) {
    log_info("this is info level log message");
}
```

### Example 2

This example manipulates headers and the request context:

```javascript
// At the router_service stage, register callbacks for processing requests and
// responses.
fn router_service(service) {
    let request_callback = Fn("process_request"); // This is standard Rhai functionality for creating a function pointer
    service.map_request(request_callback); // Register the request callback
    let response_callback = Fn("process_response"); // This is standard Rhai functionality for creating a function pointer
    service.map_response(response_callback); // Register the response callback
}

// Ensure the header is present in the request
// If an error is thrown, then the request is short-circuited to an error response
fn process_request(request) {
    log_info("processing request"); // This will appear in the router log as an INFO log
    // Verify that x-custom-header is present and has the expected value
    if request.headers["x-custom-header"] != "CUSTOM_VALUE" {
        log_error("Error: you did not provide the right custom header"); // This will appear in the router log as an ERROR log
        throw "Error: you did not provide the right custom header"; // This will appear in the errors response and short-circuit the request
    }
    // Put the header into the context and check the context in the response
    request.context["x-custom-header"] = request.headers["x-custom-header"];
}

// Ensure the header is present in the response context
// If an error is thrown, then the response is short-circuited to an error response
fn process_response(response) {
    log_info("processing response"); // This will appear in the router log as an INFO log
    // Verify that x-custom-header is present and has the expected value
    if request.context["x-custom-header"] != "CUSTOM_VALUE" {
        log_error("Error: we lost our custom header from our context"); // This will appear in the router log as an ERROR log
        throw "Error: we lost our custom header from our context"; // This will appear in the errors response and short-circuit the request
    }
}
```

### Example 3

This example converts cookies into headers for transmission to subgraphs. There is a complete working example (with tests) of this in the [examples/cookies-to-headers directory](https://github.com/apollographql/router/tree/main/examples/cookies-to-headers).

```javascript
// Call map_request with our service and pass in a string with the name
// of the function to callback
fn subgraph_service(service, name) {
    print("registering request callback"); // print() is the same as using log_info()
    let request_callback = Fn("process_request");
    map_request(service, request_callback);
}

// This will convert all cookie pairs into headers.
// If you only wish to convert certain cookies, you
// can add logic to modify the processing.
fn process_request(request) {
    print("adding cookies as headers");

    // Find our cookies
    let cookies = request.headers["cookie"].split(';');
    for cookie in cookies {
        // Split our cookies into name and value
        let k_v = cookie.split('=', 2);
        if k_v.len() == 2 {
            // trim off any whitespace
            k_v[0].trim();
            k_v[1].trim();
            // update our headers
            // Note: we must update sub_headers, since we are
            // setting a header in our sub graph request
            request.sub_headers[k_v[0]] = k_v[1];
        }
    }
}
```

There are six complete working examples (with tests) of rhai in the [examples directory](https://github.com/apollographql/router/tree/main/examples). The rhai examples are listed in the README.md.
