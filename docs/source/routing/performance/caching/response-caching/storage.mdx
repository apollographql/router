---
title: Response caching Redis storage for the GraphOS Router
description: Response caching Redis storage for GraphOS Router with GraphOS Enterprise.
minVersion: Router v2.8.0
releaseStage: preview
---


## Redis configuration

We have several options related to Redis in router's configuration in order to make sure you can scale properly and have the best performances.
For example if you need to have a different redis instance per subgraph you can configure a global redis instance (which will be used per default) and you can override and use a specific instance with their own configuration for specific subgraphs. You can also configuration default timeout and connection pool size.

```yaml title="router.yaml"
# Enable response caching globally
preview_response_cache:
  enabled: true
  subgraph:
    all:
      enabled: true
      # Configure Redis globally
      redis:
        urls: ["redis://..."]
        timeout: 2s # Optional, by default: 500ms
        ttl: 24h # Optional, by default no expiration. Default ttl for data saved in redis
    # Configure entity caching per subgraph, overrides options from the "all" section
    subgraphs:
      products:
        urls: ["redis://..."] # Override global redis instance for this specific subgraph
        pool_size: 15 # Optional. Default: 5
        namespace: products_response_cache # Optional. Prefix all the cached entries in Redis with this prefix in Redis key
      inventory:
        enabled: false # disable for a specific subgraph
```

#### Timeout
Connecting and sending commands to Redis are subject to a timeout, set by default to 500ms, that can be overriden.


#### TTL
The `ttl` option defines the default global expiration for Redis entries. By default it doesn't set any expiration for response caching.

To prevent potential cache overflow, consider setting the TTL to 24 hours or twice the median publish interval (whichever's lesser), and monitor cache utilization in your environment, especially if you cache a lot of different data.

#### Namespace

When using the same Redis instance for multiple purposes, the `namespace` option defines a prefix for all the keys defined by the router.

#### Required to start

When active, the `required_to_start` option will prevent the router from starting if it cannot connect to Redis. By default, the router will still start without a connection to Redis, which would result in only using the in-memory cache for APQ and query planning, and entity caching sending the requests to subgraphs undisturbed.

#### Pool size

The `pool_size` option defines the number of connections to Redis that the router will open. By default, the router will open a 5 connections to Redis. If there is a lot of traffic between router and Redis and/or there is some latency in those requests, it is recommended to increase the pool size to reduce that latency. For response caching you can potentially measure if you have to increase this number by looking at `apollo.router.operations.response_cache.insert` and `apollo.router.operations.response_cache.fetch` (or also check in [metrics](#metrics)) which measure the time it takes to insert and fetch data in cache, if it's long maybe it's because it takes time to acquire a connection from the pool.

### Redis URL configuration

The distributed caching configuration must contain one or more URLs using different schemes depending on the expected deployment:

* `redis` - TCP connected to a centralized server.
* `rediss` - TLS connected to a centralized server.
* `redis-cluster` - TCP connected to a cluster.
* `rediss-cluster` - TLS connected to a cluster.
* `redis-sentinel` - TCP connected to a centralized server behind a sentinel layer.
* `rediss-sentinel` - TLS connected to a centralized server behind a sentinel layer.

The URLs must have the following format:

#### One node

```
redis|rediss :// [[username:]password@] host [:port][/database]
```

Example: `redis://localhost:6379`

#### Clustered

```
redis|rediss[-cluster] :// [[username:]password@] host [:port][?[node=host1:port1][&node=host2:port2][&node=hostN:portN]]
```

or, if configured with multiple URLs:

```
[
  "redis|rediss[-cluster] :// [[username:]password@] host [:port]",
  "redis|rediss[-cluster] :// [[username:]password@] host1 [:port1]",
  "redis|rediss[-cluster] :// [[username:]password@] host2 [:port2]"
]
```

#### Sentinel

```
redis|rediss[-sentinel] :// [[username1:]password1@] host [:port][/database][?[node=host1:port1][&node=host2:port2][&node=hostN:portN]
                            [&sentinelServiceName=myservice][&sentinelUsername=username2][&sentinelPassword=password2]]
```

or, if configured with multiple URLs:

```
[
  "redis|rediss[-sentinel] :// [[username:]password@] host [:port][/database][?[&sentinelServiceName=myservice][&sentinelUsername=username2][&sentinelPassword=password2]]",
  "redis|rediss[-sentinel] :// [[username1:]password1@] host [:port][/database][?[&sentinelServiceName=myservice][&sentinelUsername=username2][&sentinelPassword=password2]]"
]
```

### TLS and authentication

For Redis TLS connections, you can set up a client certificate or override the root certificate authority by configuring `tls` in your router's [YAML config file](https://www.apollographql.com/docs/router/overview/#yaml-config-file). For example:

```yaml title="router.yaml"
# Enable response caching globally
preview_response_cache:
  enabled: true
  subgraph:
    all:
      enabled: true
      # Configure Redis globally
      redis:
        urls: [ "rediss://redis.example.com:6379" ]
        #highlight-start
        username: root
        password: ${env.REDIS_PASSWORD}
        tls:
          certificate_authorities: ${file./path/to/ca.crt}
          client_authentication:
            certificate_chain: ${file./path/to/certificate_chain.pem}
            key: ${file./path/to/key.pem}
        #highlight-end
```

### Metrics
The latency metrics are marked as experimental because we will change them if we have an upstream change in one of our depdencies.

**Connection and performance metrics:**
  - `apollo.router.cache.redis.connections`: Number of active Redis connections
  - `apollo.router.cache.redis.command_queue_length`: Commands waiting to be sent to Redis
  - `apollo.router.cache.redis.commands_executed`: Total number of Redis commands executed
  - `apollo.router.cache.redis.redelivery_count`: Commands retried due to connection issues
  - `apollo.router.cache.redis.errors`: Redis errors by type (auth, timeout, io, etc.)

**Experimental redis performance metrics:**
  - `experimental.apollo.router.cache.redis.network_latency_avg`: Average network latency to Redis
  - `experimental.apollo.router.cache.redis.latency_avg`: Average Redis command execution time
  - `experimental.apollo.router.cache.redis.request_size_avg`: Average request payload size
  - `experimental.apollo.router.cache.redis.response_size_avg`: Average response payload size

## Typical deployement

## What we tested
// Version, replicas, load tests, ...
