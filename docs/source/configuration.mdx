---
title: Apollo Router usage and config
sidebar_title: ⚙️ Usage and config
---

import { Link } from "gatsby"


> For installation instructions, see the [quickstart](../quickstart/).

You run Apollo Router with the following command (assuming you're in the same directory as the `router` executable):

```bash
./router --config configuration.yaml --supergraph supergraph-schema.graphql
```

Options are described below.

## Options

<table class="field-table api-ref">
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>

<tr class="required">
<td>

##### `-s` / `--supergraph`

</td>
<td>

The absolute or relative path to the router's [supergraph schema](https://www.apollographql.com/docs/federation/#federated-schemas).

To learn how to compose your supergraph schema with the Rover CLI, see the [Federation quickstart](https://www.apollographql.com/docs/federation/quickstart/#3-compose-the-supergraph-schema).

**Required** unless you provide this value via the `SCHEMA_PATH` environment variable.

</td>
</tr>

<tr>
<td style="min-width: 150px;">

##### `-c` / `--config`

</td>
<td>

The absolute or relative path to the router's optional [YAML configuration file](#configuration-file).

You can also provide this value via the `CONFIGURATION_PATH` environment variable.

</td>
</tr>

<tr>
<td style="min-width: 150px;">

##### `--log`

</td>
<td>

Log level which may be one of: `off`, `error`, `warn`, `info`, `debug`, or `trace`.

Default: `info`

</td>
</tr>

</tbody>
</table>

## Handling CORS

If you attempt to query Apollo Router from a browser-based client, your request might be rejected due to CORS policies.

You can configure CORS in the [YAML configuration file](#configuration-file) you can provide to Apollo Router.

Here's an example configuration for adding `localhost` to the list of approved origins:

```yaml
# examples/nodejs/configuration.yaml
server:
  listen: 127.0.0.1:4000
  cors:
    origins:
      - https://studio.apollographql.com
      - http://localhost
```

## Logging

Apollo Router detects if the stdout is a TTY and enables JSON logging only if it is not.

## Configuration file

Apollo Router takes an **optional** YAML configuration file as input via the `--config` option. To show the full possibility of options, all supported configuration options are illustrated below:

```yaml:title=configuration.yaml
#
# The Apollo Router doesn't require a configuration file to run.  This
# example is a verbose representation of possible configuration.  It's
# more of an "everything and the kitchen sink" of potential configuration
# rather than any recommendation.
#

#
# server: Configuration of the HTTP server
#
server:
  # The socket address and port to listen on
  # Defaults to 127.0.0.1:4000
  listen: 127.0.0.1:4000

  #
  # CORS (Cross Origin Resource Sharing)
  #
  cors:
    # Set to false to disallow any origin and rely exclusively on `origins`
    # Defaults to true
    allow_any_origin: true
    # List of accepted origins
    origins:
      - https://studio.apollographql.com
    # Set to true to add the `Access-Control-Allow-Credentials` header
    allow_credentials: false
    # The headers to allow.
    # Defaults to the required request header for Apollo Studio: Content-Type
    allow_headers: [ Content-Type ]
    # Allowed request methods
    # Defaults to GET, POST, OPTIONS.
    methods: [ GET, POST, OPTIONS ]
    # Which response headers should be made available to scripts running in the
    # browser in response to a cross-origin request.
    expose_headers:

#
# Subgraphs
#
# This configuration affects the communication with underlying subgraphs.
# The `subgraphs` property is a map to individual named subgraphs and should
# map to the subgraph name that is defined in the Supergraph.
#
# On each named subgraph of the subgraphs map, these properties can be set:
#
#  - routing_url
#  - layers
#
# These are explained further below.
#
# * routing_url *
#
# The URL the Router should connect to for this subgraph.
#
# By default, routing information is parsed from the supergraph which is
# typically sufficient for most environments and respects the settings which
# you've set during composition in Apollo Studio or via Rover.  Provide it here
# only to *override* the supergraph's subgraph routing URLs.
#
#
# * layers *
#
# This is a map of configurable layers which will be invoked.
#
# Layers are features (either native or extensions) which can be enabled for
# each subgraph.  Common layers are the "headers*" layers, and an example can be
# found for below.  For more information, see later in the documentation.
#

subgraphs:
  # Specifies the runtime configuration for talking to the "accounts" subgraph.
  accounts:
    # The URL of the "accounts" subgraph's GraphQL endpoint
    routing_url: http://localhost:4001/graphql

    # Layers to be applied to the "accounts" subgraph.
    layers:
      - headers_propagate:
          matching:
            regex: ^upstream-header-.*
      - headers_propagate:
          named:
            name: "old-name"
            rename: "new-name"
            default_value: "0"
      - headers_propagate:
          named:
            name: "old-name"
            rename: "new-name"
            default_value: "0"
      - headers_remove:
          name: "x-legacy-account-id"
      - headers_remove:
          matching:
            regex: ^x-deprecated.*
      - headers_insert:
          name: "router-subgraph-name"
          value: "accounts"

  # Specifies the runtime configuration for talking to the "products" subgraph.
  products:
    # The URL of the "products" subgraph's GraphQL endpoint
    routing_url: http://localhost:4003/graphql

    # Layers to be applied to the "products" subgraph.
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "products"
      - headers_remove:
          name: "x-legacy-tracking-id"


# graph configuration, see documentation below
# graph:

# spaceport configuration, see documentation below
# spaceport:

# OpenTelemetry configuration, see documentation below
# opentelemetry:
```

## Configuring headers received by subgraphs

Passing headers is supported by leveraging pre-built functionality in the Router known as "layers".  They are therefore defined in the pipeline as members of the named `subgraphs` member (e.g., `reviews`, `products`; often, certain headers only go to certain services) and further defined within the `layers` array.  The `layers` are an array since they're applied in an ordered fashion and later layers may override a previous layer's actions.

There are a few specific layers which offer different header functionality:

- **`headers_propagate`**

  This allows _selectively_ adding headers which were client-originated to the requests made to _specific_ subgraphs.
  
  > **Note:** The Router will _never_ propagate so-called [hop-by-hop headers].
  
  [hop-by-hop headers]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#hop-by-hop_headers, like `Content-length`

  They can be configured based on a `matching` pattern using [`regex`]:

  ```yaml
      - headers_propagate:
          matching:
            regex: .*
  ```

  [`regex`]: https://docs.rs/regex/latest/regex/

  Or by a static string using the `named` option.  These `named` configurations have additional flexibility since they can have either:

  * `default_value`: A value to set in the event that one was not sent by the client.
  * `rename`: Allow the header's key to be renamed to a new name.

  Additionally, both `default_value` and `rename` can be paired together:

  ```yaml
      - headers_propagate:
          named:
            name: "foo"
            default_value: "bar"
            rename: "fii"
          named:
            name: "Authorization"

- **`headers_remove`**

  The `headers_remove` layer allows removing a header that was client-originated and not sending it to a specific subgraph.  In the same way as `headers_propagate` can match either exactly or based on a regular expression using [`regex`].

> **Note:** The Router will _never_ remove so-called [hop-by-hop headers].
  ```yaml
      # Do not send this service the "Cookie" header.
      - headers_remove:
          name: "Cookie"
      - headers_remove:
          matching:
            # Remove headers using the legacy 'x-' prefix.
            regex: ^x-.*$
  ```

- **`headers_insert`**

  The `headers_insert` layer allows adding a header to requests going to a specific subgraph.  In this case, this header is a static string that is originated in the router, rather than a header being sent from the client.

  ```yaml
      - headers_insert:
          name: "sent-from-our-apollo-router"
          value: "indeed"
  ```

In order to clearly see the hierarchy, here is an example of how two headers are configured for an `accounts` and a `products` subgraph.  These two subgraphs will both be sent `router-subgraph-name` headers with either the `accounts` or `products` value, respectively.  Any other subgraph will not receive any headers at all.

```yaml
subgraphs:
  # These headers apply to the "accounts" subgraph only.
  # They will not be passed to the "products" subgraph (below).
  accounts:
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "accounts"
  products:
    # Layers to be applied to the "products" subgraph only.
  # They will not be passed to the "accounts" subgraph (above).
    layers:
      - headers_insert:
          name: "router-subgraph-name"
          value: "products"
```

## Tracing

The Apollo Router supports [OpenTelemetry](https://opentelemetry.io/), it has exporters for [Jaeger](https://www.jaegertracing.io/) and for the [OpenTelemetry Protocol (OTLP)](https://aws-otel.github.io/docs/components/otlp-exporter) over HTTP or gRPC.
It will generate a trace of the various phases of the GraphQL query and their dependencies.

It will send a `TraceParent` header to subgraphs so they can create and send their own spans under the same trace.
If the request to the Router already contains a `TraceParent` header, it will use its value as trace id instead of generating a random one.

### Using Jaeger

```yaml:title=configuration.yaml
server:
  listen: 127.0.0.1:4000
opentelemetry:
  jaeger:
    # optional: if not present, jaeger will use the default UDP agent address
    #endpoint:
      # address for the UDP agent mode
      # incomptable with collector
      # agent: "127.0.0.1:1234"

      # URL of the HTTP collector
      # collector:" http://example.org"
      # the username and password are obtained from the environment variables
      # JAEGER_USERNAME and JAEGER_PASSWORD

    # name of the service used in traces
    # defaults to router
    service_name: "router"
    
    trace_config:
      # trace sampling, possible values are `AlwaysOn`, `AlwaysOff` or `TraceIdRatioBased: number`
      # the ratio sampler takes a value between 0 and 1 and decides at the trace creation if it will
      # be recorded or not
      sampler:
        TraceIdRatioBased: 0.42
      max_events_per_span: 1
      max_attributes_per_span: 2
      max_links_per_span: 3
      max_attributes_per_event: 4
      max_attributes_per_link: 5
      resource:
        attrs:
          key1:
            String: value
          key2:
            Bool: true
          key3:
            I64: 42
          key4:
            F64: 42.0
          key5:
            Array:
              String:
                - value1
                - value2
```

### Using OTLP


```yaml:title=configuration.yaml
server:
  listen: 127.0.0.1:4000
opentelemetry:
  # Configuration to send traces and metrics to an OpenTelemetry Protocol compatible service
  otlp:
    tracing:
      exporter:
        # 'http' for OTLP/HTTP, 'grpc' for OTLP/gRPC
        http:
          # URL of the exporter
          endpoint:
          # Possible options: 'Grpc' for GRPC protocol and 'HttpBinary' for HTTP protocol with binary protobuf
          protocol: Grpc
          # timmeout in seconds
          timeout: 60
          metadata:
            - foo: bar
      trace_config:
        # trace sampling, possible values are `AlwaysOn`, `AlwaysOff` or `TraceIdRatioBased: number`
        # the ratio sampler takes a value between 0 and 1 and decides at the trace creation if it will
        # be recorded or not
        sampler:
          TraceIdRatioBased: 0.42
        max_events_per_span: 1
        max_attributes_per_span: 2
        max_links_per_span: 3
        max_attributes_per_event: 4
        max_attributes_per_link: 5
        resource:
          attrs:
            key1:
              String: value
            key2:
              Bool: true
            key3:
              I64: 42
            key4:
              F64: 42.0
            key5:
              Array:
                String:
                  - value1
                  - value2
```

## Uplink and Spaceport configuration

See the  <Link to="/studio">managed federation configuration</Link>
