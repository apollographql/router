mod conditions_validation;
mod satisfiability_error;
mod validation_context;
mod validation_state;
mod validation_traversal;

use std::sync::Arc;

use tracing::instrument;
use tracing::trace;

use crate::api_schema;
use crate::composition::satisfiability::validation_traversal::ValidationTraversal;
use crate::error::CompositionError;
use crate::error::FederationError;
use crate::merger::merge::CompositionOptions;
use crate::query_graph::QueryGraph;
use crate::query_graph::build_federated_query_graph;
use crate::query_graph::build_supergraph_api_query_graph;
use crate::schema::ValidFederationSchema;
use crate::supergraph::CompositionHint;
use crate::supergraph::Merged;
use crate::supergraph::Satisfiable;
use crate::supergraph::Supergraph;

#[instrument(skip(supergraph))]
pub fn validate_satisfiability(
    supergraph: Supergraph<Merged>,
) -> Result<Supergraph<Satisfiable>, Vec<CompositionError>> {
    let mut errors = vec![];
    let mut hints = vec![];
    let supergraph_schema = match validate_satisfiability_inner(supergraph, &mut errors, &mut hints)
    {
        Ok(supergraph_schema) => supergraph_schema,
        Err(error) => {
            return Err(vec![CompositionError::InternalError {
                message: error.to_string(),
            }]);
        }
    };
    if !errors.is_empty() {
        return Err(errors);
    }
    Ok(Supergraph::<Satisfiable>::new(supergraph_schema, hints))
}

fn validate_satisfiability_inner(
    supergraph: Supergraph<Merged>,
    errors: &mut Vec<CompositionError>,
    hints: &mut Vec<CompositionHint>,
) -> Result<ValidFederationSchema, FederationError> {
    // TODO: Avoid this clone by holding `FederationSchema` directly in `Merged` struct.
    trace!("Cloning schema to build ValidFederationSchema (we need to remove this clone)");
    let supergraph_schema = ValidFederationSchema::new(supergraph.state.schema().clone())?;
    let api_schema = api_schema::to_api_schema(supergraph_schema.clone(), Default::default())?;

    trace!("Building query graphs");
    let api_schema_query_graph =
        build_supergraph_api_query_graph(supergraph_schema.clone(), api_schema.clone())?;
    let federated_query_graph = build_federated_query_graph(
        supergraph_schema.clone(),
        api_schema,
        Some(true),
        Some(false),
    )?;
    trace!("Validating graph composition");
    validate_graph_composition(
        supergraph_schema.clone(),
        Arc::new(api_schema_query_graph),
        Arc::new(federated_query_graph),
        // TODO: Pass composition options through once upstream function APIs have been updated.
        &Default::default(),
        errors,
        hints,
    )?;
    Ok(supergraph_schema)
}

/// Validates that all the queries expressible on the API schema resulting from the composition of
/// a set of subgraphs can be executed on those subgraphs.
fn validate_graph_composition(
    // The supergraph schema generated by composition of the subgraph schemas.
    supergraph_schema: ValidFederationSchema,
    // The query graph of the API schema generated by the supergraph schema.
    api_schema_query_graph: Arc<QueryGraph>,
    // The federated query graph corresponding to the composed subgraphs.
    federated_query_graph: Arc<QueryGraph>,
    composition_options: &CompositionOptions,
    errors: &mut Vec<CompositionError>,
    hints: &mut Vec<CompositionHint>,
) -> Result<(), FederationError> {
    ValidationTraversal::new(
        supergraph_schema,
        api_schema_query_graph,
        federated_query_graph,
        composition_options,
    )?
    .validate(errors, hints)
}

#[cfg(test)]
mod tests {
    use super::*;

    const TEST_SUPERGRAPH: &str = r#"
schema
  @link(url: "https://specs.apollo.dev/link/v1.0")
  @link(url: "https://specs.apollo.dev/join/v0.5", for: EXECUTION)
  @link(url: "https://specs.apollo.dev/context/v0.1", for: SECURITY)
{
  query: Query
}

directive @context(name: String!) repeatable on INTERFACE | OBJECT | UNION

directive @context__fromContext(field: context__ContextFieldValue) on ARGUMENT_DEFINITION

directive @join__directive(graphs: [join__Graph!], name: String!, args: join__DirectiveArguments) repeatable on SCHEMA | OBJECT | INTERFACE | FIELD_DEFINITION

directive @join__enumValue(graph: join__Graph!) repeatable on ENUM_VALUE

directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet, type: String, external: Boolean, override: String, usedOverridden: Boolean, overrideLabel: String, contextArguments: [join__ContextArgument!]) repeatable on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @join__graph(name: String!, url: String!) on ENUM_VALUE

directive @join__implements(graph: join__Graph!, interface: String!) repeatable on OBJECT | INTERFACE

directive @join__type(graph: join__Graph!, key: join__FieldSet, extension: Boolean! = false, resolvable: Boolean! = true, isInterfaceObject: Boolean! = false) repeatable on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT | SCALAR

directive @join__unionMember(graph: join__Graph!, member: String!) repeatable on UNION

directive @link(url: String, as: String, for: link__Purpose, import: [link__Import]) repeatable on SCHEMA

scalar context__ContextFieldValue

interface I
  @join__type(graph: A, key: "id")
  @join__type(graph: B, key: "id")
  @context(name: "A__contextI")
{
  id: ID!
  value: Int! @join__field(graph: A)
}

input join__ContextArgument {
  name: String!
  type: String!
  context: String!
  selection: join__FieldValue!
}

scalar join__DirectiveArguments

scalar join__FieldSet

scalar join__FieldValue

enum join__Graph {
  A @join__graph(name: "A", url: "http://A")
  B @join__graph(name: "B", url: "http://B")
}

scalar link__Import

enum link__Purpose {
  """
  `SECURITY` features provide metadata necessary to securely resolve fields.
  """
  SECURITY

  """
  `EXECUTION` features provide metadata necessary for operation execution.
  """
  EXECUTION
}

type P
  @join__type(graph: A, key: "id")
  @join__type(graph: B, key: "id")
{
  id: ID!
  data: String! @join__field(graph: A, contextArguments: [{context: "A__contextI", name: "onlyInA", type: "Int", selection: " { value }"}])
}

type Query
  @join__type(graph: A)
  @join__type(graph: B)
{
  start: I! @join__field(graph: B)
}

type T implements I
  @join__implements(graph: A, interface: "I")
  @join__implements(graph: B, interface: "I")
  @join__type(graph: A, key: "id")
  @join__type(graph: B, key: "id")
{
  id: ID!
  value: Int! @join__field(graph: A)
  onlyInA: Int! @join__field(graph: A)
  p: P! @join__field(graph: A)
  sharedField: Int!
  onlyInB: Int! @join__field(graph: B)
}
    "#;

    #[test]
    // TODO: fix this panic
    #[should_panic(
        expected = r#"Supergraph should be satisfiable: [InternalError { message: "An internal error has occurred, please report this bug to Apollo.\n\nDetails: Unexpectedly missing entry for Query(supergraph) -> I(supergraph) (start) in non-trivial followup edges map" }]"#
    )]
    fn test_satisfiability_basic() {
        let supergraph = Supergraph::parse(TEST_SUPERGRAPH).unwrap();
        _ = validate_satisfiability(supergraph).expect("Supergraph should be satisfiable");
    }
}
